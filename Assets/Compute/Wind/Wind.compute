#pragma kernel ClearGrid
#pragma kernel UpdateGrid
#pragma kernel CalculatePressure
#pragma kernel ModifyPressure
#pragma kernel FindGradient
#pragma kernel MoveParticles
#pragma kernel DrawPixels

#include "Assets/Compute/Wind/Volume.hlsl"
#include "Assets/Compute/Wind/Contact.hlsl"
#include "Assets/Compute/Wind/math3.hlsl"
#include "Assets/Compute/Wind/Noise.hlsl"

RWBuffer<int> collisions_counter;
RWBuffer<int> collisions_debug;
StructuredBuffer<NoiseParameters> noise_parameters;

int collisions_debug_origin_index;
int dispatch_max_index;
float gravity;
float3 sunlight;

[numthreads(64,1,1)]
void ClearGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    elements[id.x] = int2(-1, -1);
    counter[0] = 0;
    collisions_counter[0] = 0;
    collisions_debug[id.x] = -1;
    particles[id.x].density = float2(0,0);
    
    int startI = (float)id.x / (dispatch_max_index - 1) * grid_length;
    int endI = (float)(id.x + 1) / (dispatch_max_index - 1) * grid_length;
    for (int i = startI; i <= endI; i++)
    {
        grid[i] = -1;
    }
}

[numthreads(64,1,1)]
void UpdateGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    particle p = particles[id.x];
    uint3 cell = cell_from_coord(p.position);
    int cellIndex = index_from_cell(cell);
    push_to_cell(cellIndex, id.x);
    p.grid_index = cellIndex;
    p.density = 1;
    p.gradient = float3(0, 0, 0);
    particles[id.x] = p;
}

[numthreads(64,1,1)]
void CalculatePressure (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    
    float density = 0;
    
    for (uint i = 0; i < neighbours_1_all_count; i++)
    {
        uint3 neighbourCell = cell_from_index(particles[id.x].grid_index) + neighbours_1_all[i];
        if (is_cell_valid(neighbourCell))
        {
            int index = index_from_cell(neighbourCell);
            int iterator = grid[index];
            while (iterator != -1)
            {
                int2 element = elements[iterator];
                iterator = element.y;
                if (element.x == id.x) continue;
                float dSqr = get_sqr_distance(id.x, element.x);
                if (dSqr < particle_influence_radius * particle_influence_radius)
                {
                    float d = sqrt(dSqr);
                    density += SpikyKernelPow3(d, particle_influence_radius) * 0.5f;
                }
            }
        }
    }

    float heat = max(dot(particles[id.x].position, sunlight), 0);
    float height = (sqrt(dot(particles[id.x].position, particles[id.x].position)) - 0.98f) * 15;

    float noise = GenerateFBMNoise(particles[id.x].position, noise_parameters[0]).x;
    noise = abs(noise * noise) * noise;
    noise = min(1.0f, max(0.0f, noise * 0.5f + 0.5f));

    float heatPerHeight = 1 + heat * max(1 - height, 0) * 1.1f;
    
    particles[id.x].density += density * heatPerHeight + noise * 190000 * max(1 - height, 0);// * (0.6f + noise * 0.4f);
}

void DebugRecordContact(int2 contactParticleIndex)
{
    int indexWrite = 0;
    InterlockedAdd(collisions_counter[0], 2, indexWrite);
    if (indexWrite >= dispatch_max_index)
    {
        return;
    }
    collisions_debug[indexWrite] = contactParticleIndex.x;
    collisions_debug[indexWrite+1] = contactParticleIndex.y;
}

[numthreads(64,1,1)]
void ModifyPressure (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }

    float side = max(dot(particles[id.x].position, sunlight), 0);
    float height = (sqrt(dot(particles[id.x].position, particles[id.x].position)) - 0.98f) * 20;

    float noise = GenerateFBMNoise(particles[id.x].position, noise_parameters[0]).x;
    noise = abs(noise * noise) * noise;
    noise = min(1.0f, max(0.0f, noise * 0.5f + 0.5f));

    float heat = 0.3f + side * 0.7f;
    float heatPerHeight = 1 + heat * max(1 - height, 0) * 0.5f;
    particles[id.x].density *= heatPerHeight * (0.6f + noise * 0.4f);
}

[numthreads(64,1,1)]
void FindGradient (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }

    float3 gradient = float3(0, 0, 0);
    for (int i = 0; i < neighbours_1_all_count; i++)
    {
        uint3 neighbourCell = cell_from_index(particles[id.x].grid_index) + neighbours_1_all[i];
        if (is_cell_valid(neighbourCell))
        {
            int index = index_from_cell(neighbourCell);
            int iterator = grid[index];
            while (iterator != -1)
            {
                int2 element = elements[iterator];
                iterator = element.y;

                if (element.x == id.x) continue;
                
                float dSqr = get_sqr_distance(id.x, element.x);
                /*if (dSqr < 0.00000000001)
                {
                    //int toMove = min(id.x, element.x);
                    //particles[toMove].position *= 1.1f;//GenerateDefaultFBMNoise(float3(id.x * 0.5f, element.x * 0.3f, 0.0f), noise_parameters[0]).yzw * 0.003f;
                    DebugRecordContact(int2(element.x, id.x));
                }*/
                if (dSqr < particle_influence_radius * particle_influence_radius)
                {
                    float3 contactForce = resolve_neighbour_contact(id.x, element.x, dSqr);
                    /*float length = sqrt(contactForce.x * contactForce.x + contactForce.y * contactForce.y + contactForce.z * contactForce.z);
                    if (length > 1000000)
                    {
                        DebugRecordContact(int2(id.x, element.x));
                    }*/
                    gradient += contactForce;
                }
            }
        }
    }
   
    particles[id.x].gradient += gradient;
}


[numthreads(64,1,1)]
void MoveParticles (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }

    particle p = particles[id.x];
    p.position -= p.velocity * delta_time;
    p.velocity += p.gradient * delta_time;

    float height = sqrt(p.position.x * p.position.x + p.position.y * p.position.y + p.position.z * p.position.z);
    float3 pNorm = p.position / height;
    if (height < 1 + particle_influence_radius)
    {
        float pointBHeight = min(1, height - particle_influence_radius * 0.05f);
        float3 pointB = pNorm * pointBHeight;
        float3 flatVelocity = reflect(p.velocity, pNorm, 2);
        p.velocity += contact(height - pointBHeight, p.density, p.position, p.velocity, p.density * 10, pointB, flatVelocity, 0.0f) * delta_time;
        if (height < 1)
        {
            if (dot(p.velocity, p.position) < 0)
            {
                p.velocity = reflect(p.velocity, pNorm, 0.6); // TODO: slowdown when contact
            }
            p.position = pNorm;
        }
    }
    p.velocity -= pNorm * gravity * delta_time;
    p.position += p.velocity * (delta_time * 2);
    
    particles[id.x] = p;
}

RWTexture2D<float4> outputImage;

[numthreads(8,8,1)]
void DrawPixels (uint3 id : SV_DispatchThreadID)
{
    float2 uv = float2((float)id.x / dispatch_max_index * PI, (float)id.y / dispatch_max_index * PI);
    float3 sourcePointN = sphere_to_rect(uv);
    float3 sourcePoint = sourcePointN * (1 + particle_influence_radius * 0.6f);
    uint3 cell = cell_from_coord(sourcePoint);
    int cellIndex = index_from_cell(cell);
    float4 velocityCapacitor = float4(0,0,0,0);
    float r1 = particle_influence_radius * 1.5f, r2 = particle_influence_radius * 0.5f;
    for (int i = 0; i < neighbours_1_all_count; i++)
    {
        uint3 neighbourCell = cell_from_index(cellIndex) + neighbours_1_all[i];
        if (is_cell_valid(neighbourCell))
        {
            int index = index_from_cell(neighbourCell);
            int iterator = grid[index];
            while (iterator != -1)
            {
                int2 element = elements[iterator];
                iterator = element.y;

                float dSqr = get_sqr_distance(element.x, sourcePoint);
                if (dSqr < r1 * r1)
                {
                    float d = sqrt(dSqr);
                    float influence = SpikyKernelPow2(d, r1) * 0.6f;
                    float3 velocity = particles[element.x].velocity * influence;
                    float l = sqrt(dot(velocity, velocity));
                    velocityCapacitor.xyz += velocity;
                    velocityCapacitor.w += l;
                }
                if (dSqr < r2 * r2)
                {
                    float d = sqrt(dSqr);
                    float influence = SpikyKernelPow2(d, r2);
                    float3 velocity = particles[element.x].velocity * influence;
                    float l = sqrt(dot(velocity, velocity));
                    velocityCapacitor.xyz += velocity;
                    velocityCapacitor.w += l;
                }
            }
        }
    }
    
    if (velocityCapacitor.w > 0)
    {
        //float scale = 5150000;
        velocityCapacitor.xyz /= velocityCapacitor.w;
    }
    /*float3 up = sourcePoint;
    float3 right = cross(up, float3(0, 1, 0));
    float3 fwd = cross(up, right);*/

    float3 fwd = sourcePointN;
    float3 right = cross(float3(0, 1, 0), fwd);
    float3 up = cross(fwd, right);
    float4x4 worldToLocal = float4x4(float4(right, 0), float4(up, 0), float4(fwd, 0), float4(0, 0, 0, 1));//float4x4(float4(1, 0, 0, 0), float4(0, 1, 0, 0), float4(0, 0, 1, 0), float4(0, 0, 0, 1));
    velocityCapacitor.xyz = mul(worldToLocal, velocityCapacitor.xyz);
    velocityCapacitor.xyz += float3(1, 1, 1);
    velocityCapacitor.xyz *= 0.5f;
    velocityCapacitor.z *= 0.0f;//velocityCapacitor.z / 4.0f + 0.375f
    float terminator = dot(sourcePointN, sunlight);
    float tLine = 0.7f + min(abs(terminator * 40), 1) * 0.3;
    float tShadow = max(min(terminator * 40 + 1, 1), 0.5f);
    outputImage[id.xy] = float4(velocityCapacitor.xyz * (tLine * tShadow), 1);
}