#pragma kernel ClearGrid
#pragma kernel UpdateGrid
#pragma kernel FindGradient
#pragma kernel MoveParticles

#include "Assets/Compute/Wind/Volume.hlsl"
#include "Assets/Compute/Wind/Contact.hlsl"

int dispatch_max_index;

[numthreads(64,1,1)]
void ClearGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    grid[id.x] = -1;
    counter[0] = 0;
    int startI = (float)id.x / (dispatch_max_index - 1) * elements_length;
    int endI = (float)(id.x + 1) / (dispatch_max_index - 1) * elements_length;
    for (int i = startI; i <= endI; i++)
    {
        elements[i] = int2(-1, -1);
    }
}

[numthreads(64,1,1)]
void UpdateGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x > dispatch_max_index)
    {
        return;
    }
    particle p = particles[id.x];
    uint3 cell = cell_from_coord(p.position);
    int cellIndex = index_from_cell(cell);
    int link = link_from_index(cellIndex);
    push_to_cell(link, id.x);
    p.grid_link = link;
    particles[id.x] = p;
}
int3 neighbours[7] =
{
    int3(1, 0, 0),
    int3(0, 1, 0),
    int3(1, 0, 1),
    int3(1, 1, 0),
    int3(0, 1, 1),
    int3(1, 0, 1),
    int3(1, 1, 1),
};
[numthreads(64,1,1)]
void FindGradient (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x > dispatch_max_index)
    {
        return;
    }
    for (int i = 0; i < 7; i++)
    {
        uint3 neigbourCell = cell_from_index(cell_index_from_link(particles[id.x].grid_link)) + neighbours[i];
        if (is_cell_valid(neigbourCell))
        {
            int index = index_from_cell(neigbourCell);
            int link = link_from_index(index);
            int first = grid[link];
            int iterator = first;
            while (iterator != -1)
            {
                int2 element = elements[iterator];
                iterator = element.y;
                float dSqr = get_sqr_distance(id.x, iterator.x);
                if (dSqr < particle_influence_radius * particle_influence_radius)
                {
                    resolve_neighbour_contact(id.x, iterator.x, dSqr);
                }
            }
        }
    }

    int first = grid[particles[id.x].grid_link];
    int iterator = first;
    while (iterator != -1)
    {
        int2 element = elements[iterator];
        iterator = element.y;
        
        if (element.x == id.x) continue; // discard self contact

        float dSqr = get_sqr_distance(id.x, iterator.x);
        if (dSqr == 0)
        {
            continue; //TODO: move random
        }
        if (dSqr < particle_influence_radius * particle_influence_radius)
        {
            resolve_contact(id.x, iterator.x, dSqr);
        }
    }
}

[numthreads(64,1,1)]
void MoveParticles (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x > dispatch_max_index)
    {
        return;
    }

    particle p = particles[id.x];
    p.velocity += p.gradient * delta_time;
    p.position += p.velocity * delta_time;
    particles[id.x] = p;
}