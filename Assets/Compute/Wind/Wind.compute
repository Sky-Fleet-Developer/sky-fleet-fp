#pragma kernel ClearGrid
#pragma kernel UpdateGrid
#pragma kernel FindGradient
#pragma kernel MoveParticles

#include "Assets/Compute/Wind/Volume.hlsl"
#include "Assets/Compute/Wind/Contact.hlsl"
#include "Assets/Compute/Wind/math3.hlsl"
RWBuffer<int> collisions_counter;
RWBuffer<int> collisions_debug;

int collisions_debug_origin_index;
int dispatch_max_index;
float gravity;
float push_force;

[numthreads(64,1,1)]
void ClearGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    elements[id.x] = -1;
    counter[0] = 0;
    collisions_counter[0] = 0;
    collisions_debug[id.x] = -1;
    
    int startI = (float)id.x / (dispatch_max_index - 1) * grid_length;
    int endI = (float)(id.x + 1) / (dispatch_max_index - 1) * grid_length;
    for (int i = startI; i <= endI; i++)
    {
        grid[i] = int2(-1, -1);
    }
}

[numthreads(64,1,1)]
void UpdateGrid (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    particle p = particles[id.x];
    uint3 cell = cell_from_coord(p.position);
    int cellIndex = index_from_cell(cell);
    push_to_cell(cellIndex, id.x);
    p.grid_index = cellIndex;
    particles[id.x] = p;
}
static const uint3 neighbours[13] =
{
    uint3(1, 0, 0),
    uint3(0, 1, 0),
    uint3(0, 0, 1),
    uint3(1, 0, 1),
    uint3(1, 1, 0),
    uint3(0, 1, 1),
    uint3(1, 1, 1),

    uint3(-1, 1, 1),
    uint3(-1, 0, 1),
    uint3(-1, -1, 1),
    uint3(1, -1, 0),
    uint3(1, -1, 1),
    uint3(0, -1, 1),
};

void DebugRecordContact(int contactParticleIndex)
{
    int indexWrite = 0;
    InterlockedAdd(collisions_counter[0], 1, indexWrite);
    if (indexWrite >= dispatch_max_index)
    {
        return;
    }
    collisions_debug[indexWrite] = contactParticleIndex;
}

[numthreads(64,1,1)]
void FindGradient (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }
    particle p = particles[id.x];
    p.gradient = float3(0, 0, 0);
    particles[id.x] = p;
    
    for (int i = 0; i < 13; i++)
    {
        uint3 neighbourCell = cell_from_index(particles[id.x].grid_index);
        neighbourCell.x += neighbours[i].x;
        neighbourCell.y += neighbours[i].y;
        neighbourCell.z += neighbours[i].z;
        if (is_cell_valid(neighbourCell))
        {
            int index = index_from_cell(neighbourCell);
            int iterator = grid[index];
            while (iterator != -1)
            {
                int2 element = elements[iterator];
                float dSqr = get_sqr_distance(id.x, element.x);
                if (dSqr < particle_influence_radius * particle_influence_radius)
                {
                    if (id.x == collisions_debug_origin_index)
                    {
                        DebugRecordContact(element.x);
                    }
                    if(element.x == collisions_debug_origin_index)
                    {
                        DebugRecordContact(id.x);
                    }
                    resolve_neighbour_contact(id.x, element.x, dSqr);
                }
                iterator = element.y;
            }
        }
    }

    int iterator = grid[particles[id.x].grid_index];
    while (iterator != -1)
    {
        int2 element = elements[iterator];
        iterator = element.y;
        
        if (element.x == id.x) continue; // discard self contact

        float dSqr = get_sqr_distance(id.x, element.x);
        if (dSqr == 0)
        {
            continue; //TODO: move random
        }
        if (dSqr < particle_influence_radius * particle_influence_radius)
        {
            if (id.x == collisions_debug_origin_index)
            {
                DebugRecordContact(element.x);
            }
            if(element.x == collisions_debug_origin_index)
            {
                DebugRecordContact(id.x);
            }
            resolve_contact(id.x, element.x, dSqr);
        }
    }
}

[numthreads(64,1,1)]
void MoveParticles (uint3 id : SV_DispatchThreadID)
{
    if ((int)id.x >= dispatch_max_index)
    {
        return;
    }

    particle p = particles[id.x];
    p.velocity += p.gradient * push_force * delta_time;
    p.position += p.velocity * delta_time;
    float heightSqr = p.position.x * p.position.x + p.position.y * p.position.y + p.position.z * p.position.z;
    float3 pNorm = p.position / sqrt(heightSqr);
    if (heightSqr < 1)
    {
        if (dot(p.velocity, p.position) < 0)
        {
            p.velocity = reflect(p.velocity, pNorm * 0.9f); // TODO: slowdown when contact
        }
        p.position = pNorm;
    }
    p.velocity -= pNorm * gravity * delta_time;
    particles[id.x] = p;
}